{"ast":null,"code":"/**\n * This is bound to each nested object with fragments,\n * and used as a dummy function for casting a record\n * to a Js.t object with the fragment references.\n */\nfunction getFragmentRefs() {\n  return this;\n}\n\nfunction getNewObj(maybeNewObj, currentObj) {\n  return maybeNewObj || Object.assign({}, currentObj);\n}\n\nfunction getPathName(path) {\n  return path.join(\"_\");\n}\n\nfunction makeNewPath(currentPath, newKeys) {\n  return [].concat(currentPath, newKeys);\n}\n/**\n * Runs on each object in the tree and follows the provided instructions\n * to apply transforms etc.\n */\n\n\nfunction traverse(fullInstructionMap, currentPath, currentObj, instructionMap, converters, nullableValue, instructionPaths, addFragmentOnRoot) {\n  var newObj;\n\n  if (addFragmentOnRoot) {\n    newObj = getNewObj(newObj, currentObj);\n    newObj.getFragmentRefs = getFragmentRefs.bind(newObj);\n  }\n\n  for (var key in currentObj) {\n    var isUnion = false;\n    var originalValue = currentObj[key]; // Instructions are stored by the path in the object where they apply\n\n    var thisPath = makeNewPath(currentPath, [key]);\n    var path = getPathName(thisPath);\n    var instructions = instructionMap[path];\n    var hasDeeperInstructions = instructionPaths.filter(function (p) {\n      return p.indexOf(path) === 0 && p.length > path.length;\n    }).length > 0;\n\n    if (instructions) {\n      if (currentObj[key] == null) {\n        if (instructions[\"n\"] === \"\") {\n          newObj = getNewObj(newObj, currentObj);\n          newObj[key] = nullableValue;\n        }\n      } else {\n        var shouldConvertRootObj = typeof instructions[\"r\"] === \"string\" && fullInstructionMap[instructions[\"r\"]];\n        var shouldAddFragmentFn = instructions[\"f\"] === \"\";\n        var shouldConvertEnum = typeof instructions[\"e\"] === \"string\" && !!converters[instructions[\"e\"]];\n        var shouldConvertUnion = typeof instructions[\"u\"] === \"string\" && !!converters[instructions[\"u\"]];\n        /**\n         * Handle arrays\n         */\n\n        if (Array.isArray(currentObj[key])) {\n          newObj = getNewObj(newObj, currentObj);\n          newObj[key] = currentObj[key].map(function (v) {\n            if (v == null) {\n              return nullableValue;\n            }\n\n            if (shouldConvertRootObj) {\n              return traverser(v, fullInstructionMap, converters, nullableValue, instructions[\"r\"]);\n            }\n\n            if (shouldConvertEnum) {\n              return converters[instructions[\"e\"]](v);\n            }\n\n            if (shouldConvertUnion && typeof v === \"object\" && typeof v.__typename === \"string\") {\n              isUnion = true;\n              var newPath = makeNewPath(currentPath, [key, v.__typename.toLowerCase()]);\n              var unionRootHasFragment = (instructionMap[getPathName(newPath)] || {}).f === \"\";\n              var traversedValue = traverse(fullInstructionMap, newPath, v, instructionMap, converters, nullableValue, instructionPaths, unionRootHasFragment);\n              return converters[instructions[\"u\"]](traversedValue);\n            }\n\n            if (shouldAddFragmentFn && typeof v === \"object\") {\n              var objWithFragmentFn = Object.assign({}, v);\n              objWithFragmentFn.getFragmentRefs = getFragmentRefs.bind(objWithFragmentFn);\n              return objWithFragmentFn;\n            }\n\n            return v;\n          });\n        } else {\n          /**\n           * Handle normal values.\n           */\n          var v = currentObj[key];\n\n          if (shouldConvertRootObj) {\n            newObj = getNewObj(newObj, currentObj);\n            newObj[key] = traverser(v, fullInstructionMap, converters, nullableValue, instructions[\"r\"]);\n          }\n\n          if (shouldConvertEnum) {\n            newObj = getNewObj(newObj, currentObj);\n            newObj[key] = converters[instructions[\"e\"]](v);\n          }\n\n          if (shouldConvertUnion && typeof v === \"object\" && typeof v.__typename === \"string\") {\n            isUnion = true;\n            var newPath = makeNewPath(currentPath, [key, v.__typename.toLowerCase()]);\n            var unionRootHasFragment = (instructionMap[getPathName(newPath)] || {}).f === \"\";\n            var traversedValue = traverse(fullInstructionMap, newPath, v, instructionMap, converters, nullableValue, instructionPaths, unionRootHasFragment);\n            newObj = getNewObj(newObj, currentObj);\n            newObj[key] = converters[instructions[\"u\"]](traversedValue);\n          }\n\n          if (shouldAddFragmentFn && typeof v === \"object\") {\n            newObj = getNewObj(newObj, currentObj);\n            var objWithFragmentFn = Object.assign({}, v);\n            objWithFragmentFn.getFragmentRefs = getFragmentRefs.bind(objWithFragmentFn);\n            newObj[key] = objWithFragmentFn;\n          }\n        }\n      }\n    }\n\n    if (hasDeeperInstructions && originalValue != null && !isUnion) {\n      var nextObj = newObj && newObj[key] || currentObj[key];\n\n      if (typeof nextObj === \"object\" && !Array.isArray(originalValue)) {\n        var traversedObj = traverse(fullInstructionMap, thisPath, nextObj, instructionMap, converters, nullableValue, instructionPaths);\n\n        if (traversedObj !== nextObj) {\n          newObj = getNewObj(newObj, currentObj);\n          newObj[key] = traversedObj;\n        }\n      } else if (Array.isArray(originalValue)) {\n        newObj = getNewObj(newObj, currentObj);\n        newObj[key] = nextObj.map(function (o) {\n          return typeof o === \"object\" && o != null ? traverse(fullInstructionMap, thisPath, o, instructionMap, converters, nullableValue, instructionPaths) : o;\n        });\n      }\n    }\n  }\n\n  return newObj || currentObj;\n}\n/**\n * This function takes an object (snapshot from the Relay store) and applies a\n * set of conversions deeply on the object (instructions coming from \"converters\"-prop).\n * It converts nullable values either to null or undefined, and it wraps/unwraps enums\n * and unions.\n *\n * It preserves structural integrity where possible, and return new objects where properties\n * have been modified.\n */\n\n\nfunction traverser(root, _instructionMaps, converters, nullableValue, rootObjectKey) {\n  if (!root) {\n    return nullableValue;\n  }\n\n  var instructionMaps = _instructionMaps || {};\n  var instructionMap = instructionMaps[rootObjectKey || \"__root\"]; // No instructions\n\n  if (!instructionMap) {\n    return root;\n  }\n\n  var instructionPaths = Object.keys(instructionMap); // Nothing to convert, bail early\n\n  if (instructionPaths.length === 0) {\n    return root;\n  } // We'll add a getFragmentRefs function to the root if needed here.\n  // getFragmentRefs is currently the only thing that's possible to add\n  // to the root.\n\n\n  var fragmentsOnRoot = (instructionMap[\"\"] || {}).f === \"\";\n\n  if (Array.isArray(root)) {\n    return root.map(function (v) {\n      if (v == null) {\n        return nullableValue;\n      }\n\n      return v == null ? nullableValue : traverse(instructionMaps, [], v, instructionMap, converters, nullableValue, instructionPaths, fragmentsOnRoot);\n    });\n  }\n\n  var newObj = Object.assign({}, root);\n  var v = traverse(instructionMaps, [], newObj, instructionMap, converters, nullableValue, instructionPaths, fragmentsOnRoot);\n  return v;\n}\n\nmodule.exports = {\n  traverser\n};","map":{"version":3,"sources":["/Users/Yves/Projects/Concenix/AdminPanel/node_modules/reason-relay/src/utils.js"],"names":["getFragmentRefs","getNewObj","maybeNewObj","currentObj","Object","assign","getPathName","path","join","makeNewPath","currentPath","newKeys","concat","traverse","fullInstructionMap","instructionMap","converters","nullableValue","instructionPaths","addFragmentOnRoot","newObj","bind","key","isUnion","originalValue","thisPath","instructions","hasDeeperInstructions","filter","p","indexOf","length","shouldConvertRootObj","shouldAddFragmentFn","shouldConvertEnum","shouldConvertUnion","Array","isArray","map","v","traverser","__typename","newPath","toLowerCase","unionRootHasFragment","f","traversedValue","objWithFragmentFn","nextObj","traversedObj","o","root","_instructionMaps","rootObjectKey","instructionMaps","keys","fragmentsOnRoot","module","exports"],"mappings":"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","sourcesContent":["/**\n * This is bound to each nested object with fragments,\n * and used as a dummy function for casting a record\n * to a Js.t object with the fragment references.\n */\nfunction getFragmentRefs() {\n  return this;\n}\n\nfunction getNewObj(maybeNewObj, currentObj) {\n  return maybeNewObj || Object.assign({}, currentObj);\n}\n\nfunction getPathName(path) {\n  return path.join(\"_\");\n}\n\nfunction makeNewPath(currentPath, newKeys) {\n  return [].concat(currentPath, newKeys);\n}\n\n/**\n * Runs on each object in the tree and follows the provided instructions\n * to apply transforms etc.\n */\nfunction traverse(\n  fullInstructionMap,\n  currentPath,\n  currentObj,\n  instructionMap,\n  converters,\n  nullableValue,\n  instructionPaths,\n  addFragmentOnRoot\n) {\n  var newObj;\n\n  if (addFragmentOnRoot) {\n    newObj = getNewObj(newObj, currentObj);\n    newObj.getFragmentRefs = getFragmentRefs.bind(newObj);\n  }\n\n  for (var key in currentObj) {\n    var isUnion = false;\n    var originalValue = currentObj[key];\n\n    // Instructions are stored by the path in the object where they apply\n    var thisPath = makeNewPath(currentPath, [key]);\n    var path = getPathName(thisPath);\n\n    var instructions = instructionMap[path];\n\n    var hasDeeperInstructions =\n      instructionPaths.filter(function(p) {\n        return p.indexOf(path) === 0 && p.length > path.length;\n      }).length > 0;\n\n    if (instructions) {\n      if (currentObj[key] == null) {\n        if (instructions[\"n\"] === \"\") {\n          newObj = getNewObj(newObj, currentObj);\n          newObj[key] = nullableValue;\n        }\n      } else {\n        var shouldConvertRootObj =\n          typeof instructions[\"r\"] === \"string\" &&\n          fullInstructionMap[instructions[\"r\"]];\n\n        var shouldAddFragmentFn = instructions[\"f\"] === \"\";\n\n        var shouldConvertEnum =\n          typeof instructions[\"e\"] === \"string\" &&\n          !!converters[instructions[\"e\"]];\n\n        var shouldConvertUnion =\n          typeof instructions[\"u\"] === \"string\" &&\n          !!converters[instructions[\"u\"]];\n\n        /**\n         * Handle arrays\n         */\n        if (Array.isArray(currentObj[key])) {\n          newObj = getNewObj(newObj, currentObj);\n          newObj[key] = currentObj[key].map(function(v) {\n            if (v == null) {\n              return nullableValue;\n            }\n\n            if (shouldConvertRootObj) {\n              return traverser(\n                v,\n                fullInstructionMap,\n                converters,\n                nullableValue,\n                instructions[\"r\"]\n              );\n            }\n\n            if (shouldConvertEnum) {\n              return converters[instructions[\"e\"]](v);\n            }\n\n            if (\n              shouldConvertUnion &&\n              typeof v === \"object\" &&\n              typeof v.__typename === \"string\"\n            ) {\n              isUnion = true;\n\n              var newPath = makeNewPath(currentPath, [\n                key,\n                v.__typename.toLowerCase()\n              ]);\n\n              var unionRootHasFragment =\n                (instructionMap[getPathName(newPath)] || {}).f === \"\";\n\n              var traversedValue = traverse(\n                fullInstructionMap,\n                newPath,\n                v,\n                instructionMap,\n                converters,\n                nullableValue,\n                instructionPaths,\n                unionRootHasFragment\n              );\n\n              return converters[instructions[\"u\"]](traversedValue);\n            }\n\n            if (shouldAddFragmentFn && typeof v === \"object\") {\n              var objWithFragmentFn = Object.assign({}, v);\n              objWithFragmentFn.getFragmentRefs = getFragmentRefs.bind(\n                objWithFragmentFn\n              );\n              return objWithFragmentFn;\n            }\n\n            return v;\n          });\n        } else {\n          /**\n           * Handle normal values.\n           */\n          var v = currentObj[key];\n\n          if (shouldConvertRootObj) {\n            newObj = getNewObj(newObj, currentObj);\n            newObj[key] = traverser(\n              v,\n              fullInstructionMap,\n              converters,\n              nullableValue,\n              instructions[\"r\"]\n            );\n          }\n\n          if (shouldConvertEnum) {\n            newObj = getNewObj(newObj, currentObj);\n            newObj[key] = converters[instructions[\"e\"]](v);\n          }\n\n          if (\n            shouldConvertUnion &&\n            typeof v === \"object\" &&\n            typeof v.__typename === \"string\"\n          ) {\n            isUnion = true;\n\n            var newPath = makeNewPath(currentPath, [\n              key,\n              v.__typename.toLowerCase()\n            ]);\n\n            var unionRootHasFragment =\n              (instructionMap[getPathName(newPath)] || {}).f === \"\";\n\n            var traversedValue = traverse(\n              fullInstructionMap,\n              newPath,\n              v,\n              instructionMap,\n              converters,\n              nullableValue,\n              instructionPaths,\n              unionRootHasFragment\n            );\n\n            newObj = getNewObj(newObj, currentObj);\n            newObj[key] = converters[instructions[\"u\"]](traversedValue);\n          }\n\n          if (shouldAddFragmentFn && typeof v === \"object\") {\n            newObj = getNewObj(newObj, currentObj);\n\n            var objWithFragmentFn = Object.assign({}, v);\n\n            objWithFragmentFn.getFragmentRefs = getFragmentRefs.bind(\n              objWithFragmentFn\n            );\n\n            newObj[key] = objWithFragmentFn;\n          }\n        }\n      }\n    }\n\n    if (hasDeeperInstructions && originalValue != null && !isUnion) {\n      var nextObj = (newObj && newObj[key]) || currentObj[key];\n\n      if (typeof nextObj === \"object\" && !Array.isArray(originalValue)) {\n        var traversedObj = traverse(\n          fullInstructionMap,\n          thisPath,\n          nextObj,\n          instructionMap,\n          converters,\n          nullableValue,\n          instructionPaths\n        );\n\n        if (traversedObj !== nextObj) {\n          newObj = getNewObj(newObj, currentObj);\n          newObj[key] = traversedObj;\n        }\n      } else if (Array.isArray(originalValue)) {\n        newObj = getNewObj(newObj, currentObj);\n        newObj[key] = nextObj.map(function(o) {\n          return typeof o === \"object\" && o != null\n            ? traverse(\n                fullInstructionMap,\n                thisPath,\n                o,\n                instructionMap,\n                converters,\n                nullableValue,\n                instructionPaths\n              )\n            : o;\n        });\n      }\n    }\n  }\n\n  return newObj || currentObj;\n}\n\n/**\n * This function takes an object (snapshot from the Relay store) and applies a\n * set of conversions deeply on the object (instructions coming from \"converters\"-prop).\n * It converts nullable values either to null or undefined, and it wraps/unwraps enums\n * and unions.\n *\n * It preserves structural integrity where possible, and return new objects where properties\n * have been modified.\n */\nfunction traverser(\n  root,\n  _instructionMaps,\n  converters,\n  nullableValue,\n  rootObjectKey\n) {\n  if (!root) {\n    return nullableValue;\n  }\n\n  var instructionMaps = _instructionMaps || {};\n  var instructionMap = instructionMaps[rootObjectKey || \"__root\"];\n\n  // No instructions\n  if (!instructionMap) {\n    return root;\n  }\n\n  var instructionPaths = Object.keys(instructionMap);\n\n  // Nothing to convert, bail early\n  if (instructionPaths.length === 0) {\n    return root;\n  }\n\n  // We'll add a getFragmentRefs function to the root if needed here.\n  // getFragmentRefs is currently the only thing that's possible to add\n  // to the root.\n  var fragmentsOnRoot = (instructionMap[\"\"] || {}).f === \"\";\n\n  if (Array.isArray(root)) {\n    return root.map(function(v) {\n      if (v == null) {\n        return nullableValue;\n      }\n\n      return v == null\n        ? nullableValue\n        : traverse(\n            instructionMaps,\n            [],\n            v,\n            instructionMap,\n            converters,\n            nullableValue,\n            instructionPaths,\n            fragmentsOnRoot\n          );\n    });\n  }\n\n  var newObj = Object.assign({}, root);\n\n  var v = traverse(\n    instructionMaps,\n    [],\n    newObj,\n    instructionMap,\n    converters,\n    nullableValue,\n    instructionPaths,\n    fragmentsOnRoot\n  );\n\n  return v;\n}\n\nmodule.exports = { traverser };\n"]},"metadata":{},"sourceType":"script"}